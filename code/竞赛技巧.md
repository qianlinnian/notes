1. #include<bits/stdc++.h>   是指：包含所有的库。
2. 双指针 :   
   看模板题目 code.md中
3. 前缀和：    
   求前i个数字的和，`sum[i]=sum[i-1]+a[i]`   [l,r]  sum[r]-sum[l-1]; 从区间查询变为区间端点的查询。    
   - 前缀和可以拓展到乘法吗  `可以但是有可能溢出`
   - 可以拓展到xor吗         `可以   (a xor b xor b) == a `
   - 可以拓展到求最大值最小值吗？ `如果前n个数，后n个数的最大值可以，但不能求区间的最大值。`
  
4. 差分：  
    对于一个数列an，有q次修改，每次都把数列中li到ri的每个元素加上一个数值ki求出所有修改后的每个数字的值。   
    用数组delta[i]来维护第i个数字和前一个数字的差值，（可以默认第一个数字前面有一个0）然后当需要对[li,ri]区间的每一个数字+ki时，只需要修改delta[li]和delta[ri+1]即可。所有的修改完成后，在对delta数组求和，就可以得到数列的每个元素的数值。
5. 位运算介绍  
    << 左移  >> 右移 |或 &与 ~取反 ^异或   
    ***注意位运算的优先级***    
    `a=a^b b=a^b a=a^b ==> swap(a,b)`
6. gcd
   6.1
    ``` cpp
    #include <numeric>
    // 直接使用标准库
    int result = std::gcd(a, b);
    ```
    6.2
    ```cpp
    // 递归版本
    int gcd(int a, int b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }

    // 非递归版本
    int gcd(int a, int b) {
        while (b) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }  
    ```
7. 加速
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

8. **裴蜀定理**     
   对于任意两个不全为零的整数a,b 一定存在两个整数x,y 使得 ax+by=gcd(a,b)
   裴蜀定理：对于任意两个不全为零的整数a,b 一定存在两个整数x,y 使得 ax+by=(a,b)
  exgcd 是"扩展欧几里得算法"（Extended Euclidean Algorithm）的缩写。它是欧几里得算法的扩展版本。 
    基本原理
    普通的欧几里得算法只能求两个数的最大公约数(gcd)     
    扩展欧几里得算法不仅能求gcd，还能找到裴蜀定理中的系数 x和y     
    即对于任意两个整数a和b，求解方程：ax + by = gcd(a,b)    
    ```cpp 
    int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
    }
    ```
## 数据结构

#### 哈希表
> 哈希表（Hash Table）是一种数据结构，它通过一种被称为哈希函数（Hash Function）的特殊函数，将数据的键（Key）映射到一个数组中的特定位置（称为哈希值或索引）来实现高效的数据存储和查找。

哈希表的基本概念
 键值对（Key-Value Pair）

    哈希表以键值对的形式存储数据。
    键（Key）： 数据的唯一标识。    值（Value）： 与键相关联的数据。
    哈希函数（Hash Function）

    将键转换为数组中的索引值。
    哈希函数的目标是将键均匀地分布到数组的不同位置，减少冲突。
    
    数组（Bucket）
    哈希表的底层数据结构通常是一个数组，哈希函数会将键映射到数组中的某个位置。

#### 字符串函数
substr 函数的用法
复制
string substr(size_t pos = 0, size_t len = npos) const;
参数说明：

pos：起始位置（从 0 开始计数）。
len：要截取的长度。如果 len 超过了字符串的剩余长度，则会截取到字符串的末尾。
返回值：返回一个新的字符串，包含从 pos 开始、长度为 len 的子串。

#### 集合
集合的定义：  
    在计算机科学和编程中，集合（Set） 是一种数据结构，用于存储一组互不相同的元素，且通常不保证元素的顺序。它基于数学中的集合概念，并提供高效的插入、删除和查找操作。  
集合的特点：  
    无序性：  
    集合中的元素没有固定的顺序。  
    唯一性： 
    集合中的元素是唯一的，不能重复。  
    如果尝试插入已经存在的元素，集合会忽略该操作。   
    高效性：  
    集合通常使用哈希表或平衡二叉树实现，插入、删除和查找。  
操作：
1. 添加元素 ` insert() `  
将一个元素插入集合。如果元素已经存在，集合不会重复存储。  
2. 删除元素 ` find() `  
从集合中移除一个元素。如果元素不存在，操作不会报错。  
3. 查找元素 ` erase `  
检查一个元素是否在集合中。  
4. 集合运算
并集：将两个集合的所有元素合并，去重后形成一个新的集合。  
交集：返回两个集合中共同的元素。  
差集：返回一个集合中有但另一个集合中没有的元素。  
对称差：返回两个集合中不重叠的元素。  
例题：  
[学号：查找absent学生（hard） ](https://ac.nowcoder.com/acm/contest/20960/1022)

#### pair
pair 是一个简单的容器，可以将两个值（可能是不同类型）组合在一起。
它的主要成员是 first 和 second，分别存储两个值。
可以通过直接构造或 make_pair 创建 pair。  
pair 常用于返回多个值、存储键值对或排序辅助等场景。
```cpp
template <class T1, class T2>
struct pair {
    T1 first;  // 第一个元素
    T2 second; // 第二个元素
};
```


####  sort

```cpp
// 按自定义规则排序
    sort(nums.begin(), nums.end(), compare);
```

在 C++ 中，std::sort 是一个非常强大的标准库函数，它可以对容器中的元素进行排序。默认情况下，std::sort 会使用 升序排序，即通过 < 运算符比较两个元素的大小。如果需要自定义排序规则，可以通过传递一个 自定义比较函数 或 比较函数对象 来实现。

## 算法

### 模拟、枚举

#### 差分数组
1. 定义 
    假设有一个数组 A[n]，差分数组 B[n] 定义为：
    B[1] = A[1]
    B[i] = A[i] - A[i-1] (i > 1)        
    也就是说，B[i] 表示 A[i] 与前一项的差值。
2. 性质
    原数组 A 可以通过差分数组 B 的前缀和还原：
    A[1] = B[1]
    A[2] = B[1] + B[2]
    A[3] = B[1] + B[2] + B[3] 依此类推
    区间修改的优势：

    如果要对原数组 A 的区间 [l,r] 都加上一个值 x ，只需要在差分数组上进行两次操作：
    B[l] += x
    B[r+1] -= x

#### 区间合并 
先将区间按左端点排序
如果当前区间与前一个区间重叠，就合并它们
最后统计合并后的区间中的树的数量

#### 中位数
对于一个奇数长度子序列，要使其中位数为 b，需要：
小于 b 的数字个数等于大于 b 的数字个数，再加上 b 本身，就构成了一个奇数长度子序列。
我们可以将数组中的数分为三类：
小于 b 的数
等于 b 的数
大于 b 的数
使用动态规划来统计满足条件的子序列个数。

####  加权中位数问题
性质：
当需要最小化加权绝对距离时，最佳位置是 加权中位数。
加权中位数的定义是：将所有人数分布到数轴上后，累计人数达到总人数的一半或更大时的位置。

#### 双指针
[双指针【模板】](https://ac.nowcoder.com/acm/contest/20960?from=acdiscuss)  
    思路：滑动窗口,使用双指针维护无重复元素的窗口。
    从头到尾比较，记录每个数字出现的次数和maxlen，并根据次数>1 时候，右移left 即窗口。
[小写字母](https://ac.nowcoder.com/acm/contest/20960/1015)
vector<long long> sum(2 * n + 1, 0);
#### 前缀和
> 环形结构的考虑
``` cpp    
    // 第一遍：计算前n个数的前缀和
    for(int i = 0; i < n; i++) {
        sum[i + 1] = sum[i] + dist[i];
    }
    // 第二遍：复制一遍，处理环形情况
    for(int i = n; i < 2 * n; i++) {
        sum[i + 1] = sum[i] + dist[i - n];
    }
```
#### 质数
```cpp
 bool gcd (long long a,long long b)
 {
     while(b)
     {
        
         long long tmp=b;                   
         b=a%b;
         a=tmp;
     }
     return a==1;
 }
```
#### 位运算的应用
[翻转游戏](https://ac.nowcoder.com/acm/contest/20960/1018)  
将数字利用位来表示.  
[反转游戏(hard)](https://ac.nowcoder.com/acm/contest/20960/1019)  
利用线性代数的思想，将问题转化为一个线性方程组的求解。  
> 高斯消元法

#### 高斯消元法
高斯消元法（Gaussian Elimination）是一种用于求解线性方程组的算法，主要用于将方程组转化为更简单的形式，从而便于求解。它通过一系列的行操作来简化系数矩阵，最终得到解或判断方程组的解的存在性。

 **高斯消元法的基本步骤**

1. **构造增广矩阵**：
   - 将线性方程组的系数矩阵与常数向量合并，形成一个增广矩阵。

2. **行变换**：
   - 通过以下基本操作来简化增广矩阵：
     - 交换两行。
     - 将某一行乘以一个非零常数。
     - 将某一行加到另一行上（可以是乘以一个常数后再加）。

3. **形成阶梯形矩阵**：
   - 目标是将增广矩阵转化为上三角形矩阵（或阶梯形矩阵），即所有主对角线以下的元素为零。

4. **回代求解**：
   - 从最后一行开始，逐步向上代入求解每个变量的值。   

#### 双指针算法

双指针算法是解决子序列匹配问题的经典方法。它的核心思想是通过两个指针分别遍历主字符串 s 和查询字符串 t，按顺序检查 t 的每个字符是否可以在 s 中找到。  
> 双指针算法步骤：  
    初始化两个指针：
    一个指针i用于遍历主字符串 s。
    另一个指针 j 用于遍历查询字符串 t。  
    匹配字符：  
    如果 s[i]==t[j]s[i]==t[j]，说明当前字符匹配，移动 j 指针。无论是否匹配，i 指针始终向前移动。  
    判断结果：  
    如果 j 最终能遍历完整个t（即 j==t.length()j==t.length()），说明 t 是s 的子序列。  
    否则，t 不是 s 的子序列。  
    重复上述过程：  
    对于每个查询字符串 t，重复上述操作。
### 贪心
[图论+优化问题](https://ac.nowcoder.com/acm/contest/20960/1026)   
思路：  
统计横向通道的贡献：对于每一行之间，如果设置一个横向通道，可以切断哪些边。  
统计纵向通道的贡献：对于每一列之间，如果设置一个纵向通道，可以切断哪些边。  
贪心选择通道位置：根据通道的贡献值（切断的边数），选择对切断边贡献最大的k个横向通道和l个纵向通道。  


### 快速排序